<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE stax SYSTEM "stax.dtd">
<!--
 ! CDDL HEADER START
 !
 ! The contents of this file are subject to the terms of the
 ! Common Development and Distribution License, Version 1.0 only
 ! (the "License").  You may not use this file except in compliance
 ! with the License.
 !
 ! You can obtain a copy of the license at
 ! trunk/opends/resource/legal-notices/OpenDS.LICENSE
 ! or https://OpenDS.dev.java.net/OpenDS.LICENSE.
 ! See the License for the specific language governing permissions
 ! and limitations under the License.
 !
 ! When distributing Covered Code, include this CDDL HEADER in each
 ! file and include the License file at
 ! trunk/opends/resource/legal-notices/OpenDS.LICENSE.  If applicable,
 ! add the following below this CDDL HEADER, with the fields enclosed
 ! by brackets "[]" replaced with your own identifying information:
 !      Portions Copyright [yyyy] [name of copyright owner]
 !
 ! CDDL HEADER END
 !
 !      Portions Copyright 2006-2007 Sun Microsystems, Inc.
 ! -->
<stax>
  <function name="checkRC">
    <function-prolog>
      This function checks a return code against an expected return code
    </function-prolog>

    <function-map-args>
      <function-required-arg name="returncode">
        return code received from command
      </function-required-arg>
      <function-required-arg name="result">
        the output of the result
      </function-required-arg>
      <function-optional-arg name="expected" default="0">
        the expected return code
      </function-optional-arg>
    </function-map-args>

    <sequence>
      <if expr="returncode == expected">
        <sequence>
          <if expr="result == ''">
            <message log="1">
              'Success: RC=%s, Result=Ok' % (returncode)
            </message>
          <else>
            <message log="1">
              'Success: RC=%s, Result=%s' % (returncode,result)
            </message>
          </else>
          </if>
        </sequence>
        <else>
          <sequence>
            <message log="1" level="'Error'">
              'Error: RC=%s, Expected %s, Result=%s' % (returncode,expected,result)
            </message>
          </sequence>
        </else>
      </if>
    </sequence>
  </function>

  <function name="checktestRC">
    <function-prolog>
      This function checks the return code against an expected return code for a testcase
    </function-prolog>
    <function-map-args>
      <function-required-arg name="returncode">
        return code received from command
      </function-required-arg>
      <function-required-arg name="result">
        the output of the result
      </function-required-arg>
      <function-optional-arg name="expected" default="0">
        the expected return code
      </function-optional-arg>
    </function-map-args>
    <sequence>
      <if expr="returncode == expected">
        <sequence>
          <tcstatus result="'pass'"/>
          <message log="1">
            'Success: RC=%s, Result=%s' % (returncode,result)
          </message>
        </sequence>
        <else>
          <sequence>
            <tcstatus result="'fail'"/>
            <message log="1" level="'Error'">
              'Error: RC=%s, Expected %s, Result=%s' % (returncode,expected,result)
            </message>
          </sequence>
        </else>
      </if>
    </sequence>
  </function>

  <function name="checktestString">
    <function-prolog>
      This function checks the return string against an expected return substring for a testcase
    </function-prolog>
    <function-map-args>
      <function-required-arg name="expectedString">
        the substring expected from the command
      </function-required-arg>
      <function-required-arg name="returnString">
        the return string received from command
      </function-required-arg>
    </function-map-args>
    <sequence>
      <script> 
        searchre = re.compile('%s' % expectedString)
      </script> 

      <if expr='re.search(searchre, returnString) != None'>
        <sequence>
          <tcstatus result="'pass'"/>
          <message log="1">
            'Success: Found substring, %s, in the return string' % (expectedString)
          </message>
        </sequence>
        <else>
          <sequence>
            <tcstatus result="'fail'"/>
            <message log="1" level="'Error'">
              'Error: Did not find substring, %s, in the return string, %s' % (expectedString, returnString)
            </message>
          </sequence>
        </else>
      </if>
    </sequence>
  </function>

  <function name="checktestStringNotPresent">
    <function-prolog>
      This function checks the return string against an expected return substring that should not be present for a testcase
    </function-prolog>
    <function-map-args>
      <function-required-arg name="testString">
        the substring being tested from the command
      </function-required-arg>
      <function-required-arg name="returnString">
        the return string received from command
      </function-required-arg>
    </function-map-args>

    <sequence>
      <script>
        searchre = re.compile('%s' % testString)
      </script>
      <if expr='re.search(searchre, returnString) == None'>
        <sequence>
          <tcstatus result="'pass'"/>
          <message log="1">
            'Success: Did Not Find substring, %s, in the return string' % (testString)
          </message>
        </sequence>
        <else>
          <sequence>
            <tcstatus result="'fail'"/>
            <message log="1" level="'Error'">
              'Error: Found substring, %s, in the return string, %s' % (testString, returnString)
            </message>
          </sequence>
        </else>
      </if>
    </sequence>
  </function>

  <function name="searchStringForSubstring">
    <function-prolog>
      This function simply searches a string for a substring
    </function-prolog>
    <function-map-args>
      <function-required-arg name="testString">
        the substring being tested from the command
      </function-required-arg>
      <function-required-arg name="returnString">
        the return string received from command
      </function-required-arg>
    </function-map-args>

    <sequence>
      <script>
        searchre = re.compile(testString)
      </script>
      <if expr='re.search(searchre, returnString) == None'>
        <sequence>
          <script>returnCode='0'</script>
          <message log="1">
            'Result: Did Not Find substring, %s, in the return string' % (testString)
          </message>
        </sequence>
        <else>
          <sequence>
            <script>returnCode='1'</script>
            <message log="1">
              'Result: Found substring, %s, in the return string' % (testString)
            </message>
          </sequence>
        </else>
      </if>
      <return>returnCode</return>
    </sequence>
  </function>
  
  <function name="isAlive">
    <function-prolog>
      Checks that the ldap server is running
    </function-prolog>
    <function-map-args>
      <function-required-arg name="noOfLoops">
        Number of loops
      </function-required-arg>
      <function-required-arg name="noOfMilliSeconds">
        Number of seconds
      </function-required-arg>
    </function-map-args>

      <sequence>
        <script>ldapRC=9999</script>
        <loop from="1" to="noOfLoops" while="ldapRC != 0">
          <sequence>
            <call function="'SearchObject'">
              { 'dsInstanceHost' : DIRECTORY_INSTANCE_HOST ,
                'dsInstancePort' : DIRECTORY_INSTANCE_PORT ,
                'dsInstanceDn'   : DIRECTORY_INSTANCE_DN ,
                'dsInstancePswd' : DIRECTORY_INSTANCE_PSWD ,
                'dsBaseDN'       : 'cn=config' ,
                'dsFilter'	     : 'objectclass=*' ,
                'extraParams'    : '-s "base"' }
            </call>

            <script>
              ldapRC=RC
            </script>

            <call function="'Sleep'">
              { 'sleepForMilliSeconds'  : noOfMilliSeconds }
            </call>
          </sequence>
        </loop>
      </sequence>
  </function>

  <function name="Sleep">
    <function-prolog>
      Sleep for number of milliseconds
    </function-prolog>
    <function-map-args>
      <function-required-arg name="sleepForMilliSeconds">
        Number of milliseconds to sleep
      </function-required-arg>
    </function-map-args>
    
    <sequence>
      <stafcmd name="'STAF Command: Delay'">
        <location>'%s' % (hostname)</location>
        <service>'delay'</service>
        <request>
          'delay %i' % sleepForMilliSeconds
        </request>
      </stafcmd>

      <call function="'checkRC'">
        { 'returncode' : RC ,
          'result'     : STAFResult }
      </call>
    </sequence>
  </function>

  <function name="setOSvariables">
    <function-prolog>
      Set OS related variables
    </function-prolog>
    <function-map-args>
      <function-required-arg name="hostname">
        Name of host
      </function-required-arg>
    </function-map-args>
    <sequence>
      <stafcmd name="'STAF Command: Get OS Name'">
        <location>'%s' % (hostname)</location>
        <service>'var'</service>
        <request>
          'get system var STAF/Config/OS/Name'
        </request>
      </stafcmd>
      <message>
        'OS Name= %s' % STAFResult
      </message>
      <return>STAFResult</return>
    </sequence>
  </function>

  <function name="testCase_StartBanner">
    <function-prolog>
      Pretty prints a banner at the start of a test.
    </function-prolog>
    <function-no-args />
    <sequence>
      <message>
        '### Starting test case %s. ###' % STAXCurrentTestcase
      </message>
    </sequence>
  </function>

  <function name="testCase_EndBanner">
    <function-prolog>
      Pretty prints a banner at the end of a test.
    </function-prolog>
    <function-no-args />
    <sequence>
      <message>
        '### Ending test case %s. ###' % STAXCurrentTestcase
      </message>
    </sequence>
  </function>

  <function name="testCase_Preamble">
    <function-prolog>
      Performs all the preoperations for a test case
    </function-prolog>
    <function-no-args />
      <sequence>
        <call function="'testCase_StartBanner'" />
    </sequence>
  </function>

  <function name="testCase_Postamble">
    <function-prolog>
      Performs all the post operations for a test suite
    </function-prolog>
    <function-no-args />
    <sequence>
      <call function="'queryTestcase'" />
      
      <script>
        if STAFResult.has_key('numPasses'):
          numPass=int(STAFResult['numPasses'])
        else:
          numPass=int(0)
          
        if STAFResult.has_key('numFails'):
          numFail=int(STAFResult['numFails'])
        else:
          numFail=int(0)
      </script>
             
      <if expr="numFail &gt; 0">
        <message>'## Test Verdict: FAIL ##'</message>
      <else>
        <message>'## Test Verdict: PASS ##'</message>
      </else>
      </if>    
      
      <call function="'testCase_EndBanner'" />
    </sequence>
  </function>

  <function name="testSuite_Preamble">
    <function-prolog>
      Performs all the pre operations for a test suite
    </function-prolog>
    <function-no-args />
    <sequence>

      <!-- Take the values from the current test path -->     
      <script>
        if not CurrentTestPath.has_key('group'):
          CurrentTestPath['group']='unknown-group'
                   
        if not CurrentTestPath.has_key('suite'):
          CurrentTestPath['suite']='unknown-suite'
          
        ThisGroupName=CurrentTestPath['group']  
        ThisSuiteName=CurrentTestPath['suite']
      </script>

      <!-- Start time of test suite -->      
      <script>
        TestSuiteStartTime=strftime("%Y%m%d@%H:%M:%S",localtime())
      </script>
          
      <message>
        '#### %s/%s suite preamble ####' % (ThisGroupName,ThisSuiteName)
      </message>
        
    </sequence>
  </function>

  <function name="testSuite_Postamble">
    <function-prolog>
      Performs all the post operations for a test suite
    </function-prolog>
    <function-no-args />
    <sequence>
    
      <!-- Take the values from the current test path -->     
      <script>
        if CurrentTestPath.has_key('suite'):
          ThisSuiteName=CurrentTestPath['suite']
        else:
          ThisSuiteName='unknown-suite'
          
        if CurrentTestPath.has_key('group'):
          ThisGroupName=CurrentTestPath['group']
        else:
          ThisGroupName='unknown-group'
      </script>
    
      <message>
        '#### %s/%s suite postamble ####' % (ThisGroupName,ThisSuiteName)
      </message>

      <!-- Start time of test suite -->      
      <script>
        TestSuiteEndTime=strftime("%Y%m%d@%H:%M:%S",localtime())
      </script>
      
      <!-- Format the test group and suite names to create folder -->
      <script>        
        FormattedTestcase=format_testcase()
        FormattedTestgroup=FormattedTestcase.group(ThisGroupName)         
        FormattedTestsuite=FormattedTestcase.suite(ThisSuiteName)
             
        TestLogDir= '%s/%s' % (LogDir,FormattedTestgroup)
        TestLogFile='%s/%s' % (TestLogDir,FormattedTestsuite) 
      </script>
                  
      <call function="'WriteLogsForTestCase'">
        { 'starttime' : TestSuiteStartTime,
          'endtime'   : TestSuiteEndTime,
          'tofile'    : TestLogFile }
      </call>

      <script>
        if CurrentTestPath.has_key('suite'):
           del CurrentTestPath['suite']
      </script>
              
    </sequence>
  </function>

  <function name="testGroup_Preamble">
    <function-prolog>
      Performs all the pre operations for a test group
    </function-prolog>
    <function-no-args />
    <sequence>
    
      <!-- Take the values from the current test path -->     
      <script>
        if not CurrentTestPath.has_key('group'):
          CurrentTestPath['group']='unknown-group'
        
        ThisGroupName=CurrentTestPath['group']          
      </script>
      
      <message>'##### %s group preamble #####' % ThisGroupName</message>
      
    </sequence>
  </function>

  <function name="testGroup_Postamble">
    <function-prolog>
      Performs all the post operations for a test group
    </function-prolog>
    <function-no-args />
    <sequence>
    
      <script>
        if CurrentTestPath.has_key('group'):
          ThisGroupName=CurrentTestPath['group']
        else:
          ThisGroupName='unknown-group'
      </script>
      
      <message>'##### %s group postamble #####' % ThisGroupName</message>
      
      <script>
        if CurrentTestPath.has_key('group'):
          del CurrentTestPath['group']
      </script>
      
    </sequence>
  </function>
  
  <function name="WriteLogsForTestCase">

    <function-prolog>
      Queries the staf logs for the test case and write to file as text
    </function-prolog>

    <function-map-args>
      <function-required-arg name="starttime">
        timestamp to start logging from
      </function-required-arg>
      <function-required-arg name="endtime">
        timestamp to start logging from
      </function-required-arg>
      <function-required-arg name="tofile">
        timestamp to start logging from
      </function-required-arg>
    </function-map-args>

    <sequence>

      <call function="'queryLogs'">
        { 'location'  : STAXServiceMachine,
          'logname'   : 'STAX_Job_%s_User' % STAXJobID, 
          'startfrom' : starttime,
          'endat'     : endtime }
      </call>

      <call function="'WriteLogs'">
        { 'queryresult' : STAFResult, 
          'logfile'     : tofile }
      </call>

    </sequence>

  </function>

  <function name="WriteLogs">

    <function-prolog>
      Process staf log query results and write them to a file
    </function-prolog>

    <function-map-args>
      <function-required-arg name="queryresult">
        result of the staf log query
      </function-required-arg>
      <function-required-arg name="logfile">
        name of the log file to where results are written
      </function-required-arg>
    </function-map-args>

    <sequence>

      <message>'Creating test log %s' % logfile</message>
     
      <script>
        NewLogDir=posixpath.dirname(logfile)
      </script>
      
      <call function="'createFolder'">
        { 'location'   : STAXServiceMachine, 
          'foldername' : NewLogDir }
      </call>

      <script>
        testlogfh=open(logfile,'w')
      </script>
           
      <iterate var="element" in="queryresult">
        <script>
          level=element['level'] 
          message=element['message']
          timestamp=element['timestamp']

          testlogfh.write('%s %s %s\n' % (timestamp,level,message))
        </script>

      </iterate>

      <script>testlogfh.close()</script>

    </sequence>

  </function>

</stax>

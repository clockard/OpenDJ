<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE stax SYSTEM "../stax.dtd">
<!--
 ! CDDL HEADER START
 !
 ! The contents of this file are subject to the terms of the
 ! Common Development and Distribution License, Version 1.0 only
 ! (the "License").  You may not use this file except in compliance
 ! with the License.
 !
 ! You can obtain a copy of the license at
 ! trunk/opends/resource/legal-notices/OpenDS.LICENSE
 ! or https://OpenDS.dev.java.net/OpenDS.LICENSE.
 ! See the License for the specific language governing permissions
 ! and limitations under the License.
 !
 ! When distributing Covered Code, include this CDDL HEADER in each
 ! file and include the License file at
 ! trunk/opends/resource/legal-notices/OpenDS.LICENSE.  If applicable,
 ! add the following below this CDDL HEADER, with the fields enclosed
 ! by brackets "[]" replaced with your own identifying information:
 !      Portions Copyright [yyyy] [name of copyright owner]
 !
 ! CDDL HEADER END
 !
 !      Portions Copyright 2006-2007 Sun Microsystems, Inc.
 ! -->
<stax>
  <function name="checkRC">
    <function-prolog>
      This function checks a return code against an expected return code
    </function-prolog>
    
    <function-map-args>
      <function-arg-def name="returncode" type="required">
        <function-arg-description>
          return code received from command
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>   
      <function-arg-def name="result" type="required">
        <function-arg-description>
          the output of the result
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>          
      <function-arg-def name="expected" type="optional" default="0">
        <function-arg-description>
          the expected return code
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>
    </function-map-args>

    <sequence>
      <if expr="expected == NO_CHECK">
        <return/>
      </if>                
      <if expr="returncode == expected">
        <sequence>
          <if expr="result == ''">
            <message log="1">
              'RC=%s, Result=Ok' % (returncode)
            </message>
          <else>
            <message log="1">
              'RC=%s, Result=%s' % (returncode,result)
            </message>
          </else>
          </if>
        </sequence>
        <else>
          <sequence>
            <message log="1" level="'Error'">
              'RC=%s, Expected %s, Result=%s' % (returncode,expected,result)
            </message>
          </sequence>
        </else>
      </if>
      <return>RC</return>
    </sequence>
  </function>

  <function name="checktestRC">
    <function-prolog>
      This function checks the return code against an expected return code for a testcase
    </function-prolog>
    <function-map-args>
      <function-arg-def name="returncode" type="required">
        <function-arg-description>
          return code received from command
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>   
      <function-arg-def name="result" type="required">
        <function-arg-description>
          the output of the result
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>          
      <function-arg-def name="expected" type="optional" default="0">
        <function-arg-description>
          the expected return code
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>
    </function-map-args>  
    <sequence>		
      <if expr="expected == NO_CHECK">
        <return/>
      </if>        
      <if expr="returncode == expected">
        <sequence>
          <if expr="STAXCurrentTestcase != None">
            <sequence>
              <tcstatus result="'pass'"/>				  
            </sequence>
          </if>  			
          <message log="1">
            'SUCCESS: RC=%s, Expected %s, Result=%s' % (returncode,expected,result)
          </message>
          <script>
            RC=0
          </script>
        </sequence>
      <else>
        <sequence>
          <if expr="STAXCurrentTestcase != None">
            <sequence>
              <tcstatus result="'fail'"/>				  
            </sequence>
          </if>  			           
          <message log="1" level="'Error'">
            'ERROR : RC=%s, Expected %s, Result=%s' % (returncode,expected,result)
          </message>
        </sequence>
      </else>
      </if>
    </sequence>
  </function>

  <function name="checktestString">
    <function-prolog>
      This function checks the return string against an expected return substring for a testcase
    </function-prolog>
    
    <function-map-args>
      <function-arg-def name="expectedString" type="required">
        <function-arg-description>
          the substring expected from the command
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>   
      <function-arg-def name="returnString" type="required">
        <function-arg-description>
          the return string received from command
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>          
    </function-map-args>
    
    <sequence>
      <script> 
        searchre = re.compile('%s' % expectedString)
      </script> 

      <if expr='re.search(searchre, returnString) != None'>
        <sequence>
          <tcstatus result="'pass'"/>
          <message log="1">
            'Found substring, %s, in the return string' % (expectedString)
          </message>
        </sequence>
        <else>
          <sequence>
            <tcstatus result="'fail'"/>
            <message log="1" level="'Error'">
              'Did not find substring, %s, in the return string, %s' % (expectedString, returnString)
            </message>
          </sequence>
        </else>
      </if>
    </sequence>
  </function>

  <function name="checktestStringNotPresent">
    <function-prolog>
      This function checks the return string against an expected return substring that should not be present for a testcase
    </function-prolog>
    <function-map-args>
      <function-arg-def name="testString" type="required">
        <function-arg-description>
          the substring being tested from the command
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>   
      <function-arg-def name="returnString" type="required">
        <function-arg-description>
          the return string received from command
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>          
    </function-map-args>

    <sequence>
      <script>
        searchre = re.compile('%s' % testString)
      </script>
      <if expr='re.search(searchre, returnString) == None'>
        <sequence>
          <tcstatus result="'pass'"/>
          <message log="1">
            'Did Not Find substring, %s, in the return string' % (testString)
          </message>
        </sequence>
        <else>
          <sequence>
            <tcstatus result="'fail'"/>
            <message log="1" level="'Error'">
              'Found substring, %s, in the return string, %s' % (testString, returnString)
            </message>
          </sequence>
        </else>
      </if>
    </sequence>
  </function>

  <function name="searchStringForSubstring">
    <function-prolog>
      This function simply searches a string for a substring
    </function-prolog>
    
    <function-map-args>
      <function-arg-def name="testString" type="required">
        <function-arg-description>
          the substring being tested from the command
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>   
      <function-arg-def name="returnString" type="required">
        <function-arg-description>
          the return string received from command
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>
    </function-map-args>

    <sequence>
      <script>
        searchre = re.compile(testString)
      </script>
      <if expr='re.search(searchre, returnString) == None'>
        <sequence>
          <script>returnCode='0'</script>
          <message log="1">
            'Did Not Find substring, %s, in the return string' % (testString)
          </message>
        </sequence>
        <else>
          <sequence>
            <script>returnCode='1'</script>
            <message log="1">
              'Found substring, %s, in the return string' % (testString)
            </message>
          </sequence>
        </else>
      </if>
      <return>returnCode</return>
    </sequence>
  </function>
  
  <function name="isAlive" scope="local">
    <function-prolog>
      Checks that the ldap server is running
    </function-prolog>
    <function-map-args>
      <function-arg-def name="location" type="optional" default="'%s' % STAF_REMOTE_HOSTNAME">
        <function-arg-description>
          Location of target host
      </function-arg-description>
      <function-arg-property name="type" value="hostname"/>
      </function-arg-def>
      <function-arg-def name="dsPath" type="optional" default="'%s/%s' % (DIRECTORY_INSTANCE_DIR,OPENDSNAME)">
        <function-arg-description>
          Pathname to installation root
        </function-arg-description>
        <function-arg-property name="type" value="pathname"/>
      </function-arg-def>
      <function-arg-def name="noOfLoops" type="required">
        <function-arg-description>
          Number of iterations
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>      
      <function-arg-def name="noOfMilliSeconds" type="required">
        <function-arg-description>
          Number of seconds to wait between iterations
        </function-arg-description>
        <function-arg-property name="type" value="seconds"/>
      </function-arg-def>
      <function-arg-def name="dsInstanceHost" type="optional" default="'%s' % DIRECTORY_INSTANCE_HOST">
        <function-arg-description>
          Directory server hostname or IP address
        </function-arg-description>
        <function-arg-property name="type" value="hostname"/>
      </function-arg-def>      
      <function-arg-def name="dsInstancePort" type="optional" default="'%s' % DIRECTORY_INSTANCE_PORT">
        <function-arg-description>
          Directory server port number
        </function-arg-description>
        <function-arg-property name="type" value="Port number"/>
      </function-arg-def>
      <function-arg-def name="dsInstanceDn" type="optional" default="'%s' % DIRECTORY_INSTANCE_DN">
        <function-arg-description>
          Bind DN
        </function-arg-description>
        <function-arg-property name="type" value="DN"/>
      </function-arg-def> 
      <function-arg-def name="dsInstancePswd" type="optional" default="'%s' % DIRECTORY_INSTANCE_PSWD">
        <function-arg-description>
          Bind password
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>      
    </function-map-args>
      
    <sequence>
      <!-- Local variables -->
      <script>
        mylocation=location
        mypath=dsPath
        myhost=dsInstanceHost
        myport=dsInstancePort
        mydn=dsInstanceDn
        mypswd=dsInstancePswd
      </script>

      <script>ldapRC=9999</script>
      <loop from="1" to="noOfLoops" while="ldapRC != 0">
        <sequence>
          <call function="'SearchObject'">
            { 'location'       : mylocation,
              'dsPath'         : mypath,
              'dsInstanceHost' : myhost ,
              'dsInstancePort' : myport ,
              'dsInstanceDn'   : mydn ,
              'dsInstancePswd' : mypswd ,
              'dsScope'        : 'base' ,
              'dsBaseDN'       : 'cn=config' ,
              'dsFilter'       : 'objectclass=*' ,
              'expectedRC'     : 'noCheck'
            }
          </call>

          <script>
            ldapRC=RC
          </script>

          <call function="'Sleep'">
            { 'sleepForMilliSeconds'  : noOfMilliSeconds }
          </call>
          
        </sequence>
      </loop>

    </sequence>
  </function>

  <function name="Sleep">
    <function-prolog>
      Sleep for number of milliseconds
    </function-prolog>
    <function-map-args>
      <function-arg-def name="location" type="optional" default="'%s' % STAXServiceMachine">
        <function-arg-description>
          Location of target host
      </function-arg-description>
      <function-arg-property name="type" value="hostname"/>
      </function-arg-def>    
      <function-arg-def name="sleepForMilliSeconds" type="required">
        <function-arg-description>
          Number of milliseconds to sleep
        </function-arg-description>
        <function-arg-property name="type" value="seconds"/>
      </function-arg-def>
    </function-map-args>
    
    <sequence>
      <stafcmd name="'STAF Command: Delay'">
        <location>'%s' % location</location>
        <service>'delay'</service>
        <request>
          'delay %i' % sleepForMilliSeconds
        </request>
      </stafcmd>

      <call function="'checkRC'">
        { 'returncode' : RC ,
          'result'     : STAFResult }
      </call>
    </sequence>
  </function>

  <function name="setOSvariables">
    <function-prolog>
      Set OS related variables
    </function-prolog>
    <function-map-args>
      <function-arg-def name="hostname" type="required">
        <function-arg-description>
          Name of host on which to retrieve variables
        </function-arg-description>
        <function-arg-property name="type" value="hostname"/>
      </function-arg-def>
    </function-map-args>
    <sequence>
      <stafcmd name="'STAF Command: Get OS Name'">
        <location>'%s' % hostname</location>
        <service>'var'</service>
        <request>
          'get system var STAF/Config/OS/Name'
        </request>
      </stafcmd>
      <message>
        'OS Name= %s' % STAFResult
      </message>
      <return>STAFResult</return>
    </sequence>
  </function>

  <function name="testCase_StartBanner">
    <function-prolog>
      Pretty prints a banner at the start of a test.
    </function-prolog>
    <function-no-args />
    <sequence>
      <message>''</message>
      <message>'****************************************************'</message>
      <message>'*** STARTING TEST CASE %s.' % STAXCurrentTestcase</message>
      <message>'***'</message>
    </sequence>
  </function>

  <function name="testCase_EndBanner">
    <function-prolog>
      Pretty prints a banner at the end of a test.
    </function-prolog>
    <function-no-args />
    <sequence>
      <message>'***'</message>
      <message>'*** ENDING TEST CASE %s.' % STAXCurrentTestcase</message>
      <message>'****************************************************'</message>
      <message>''</message>
    </sequence>
  </function>

  <function name="testCase_Preamble">
    <function-prolog>
      Performs all the preoperations for a test case
    </function-prolog>
    <function-no-args />
      <sequence>
        <call function="'testCase_StartBanner'" />
    </sequence>
  </function>

  <function name="testCase_Postamble">
    <function-prolog>
      Performs all the post operations for a test suite
    </function-prolog>
    <function-no-args />
    <sequence>

      <!-- Check the SignalRaised flag -->    
      <if expr="SignalRaised">
        <sequence>
          <message>
            'A signal (%s) was raised during this test case' % SignalRaised
          </message>
          <tcstatus result="'fail'"/>
        </sequence>
      </if>

      <!-- Reset the SignalRaised flag -->
      <script>
        SignalRaised='' 
      </script>

      <!-- Query the test case results -->            
      <call function="'queryTestcase'" />
      
      <script>
        if STAFResult.has_key('numPasses'):
          numPass=int(STAFResult['numPasses'])
        else:
          numPass=int(0)
          
        if STAFResult.has_key('numFails'):
          numFail=int(STAFResult['numFails'])
        else:
          numFail=int(0)
      </script>
             
      <if expr="numFail &gt; 0">
        <message>'## Test Verdict: FAIL ##'</message>
      <else>
        <message>'## Test Verdict: PASS ##'</message>
      </else>
      </if>    
      
      <call function="'testCase_EndBanner'" />
    </sequence>
  </function>

  <function name="testSuite_Preamble">
    <function-prolog>
      Performs all the pre operations for a test suite
    </function-prolog>
    <function-no-args />
    <sequence>

      <!-- Take the values from the current test path -->     
      <script>
        if not CurrentTestPath.has_key('group'):
          CurrentTestPath['group']='unknown-group'
                   
        if not CurrentTestPath.has_key('suite'):
          CurrentTestPath['suite']='unknown-suite'
          
        ThisGroupName=CurrentTestPath['group']  
        ThisSuiteName=CurrentTestPath['suite']
      </script>

      <!-- Start time of test suite -->      
      <script>
        TestSuiteStartTime=strftime("%Y%m%d@%H:%M:%S",localtime())
      </script>
          
      <message>
        '#### %s/%s suite preamble ####' % (ThisGroupName,ThisSuiteName)
      </message>
        
    </sequence>
  </function>

  <function name="testSuite_Postamble">
    <function-prolog>
      Performs all the post operations for a test suite
    </function-prolog>
    <function-no-args />
    <sequence>
    
      <!-- Take the values from the current test path -->     
      <script>
        if CurrentTestPath.has_key('suite'):
          ThisSuiteName=CurrentTestPath['suite']
        else:
          ThisSuiteName='unknown-suite'
          
        if CurrentTestPath.has_key('group'):
          ThisGroupName=CurrentTestPath['group']
        else:
          ThisGroupName='unknown-group'
      </script>
    
      <message>
        '#### %s/%s suite postamble ####' % (ThisGroupName,ThisSuiteName)
      </message>

      <!-- Start time of test suite -->      
      <script>
        TestSuiteEndTime=strftime("%Y%m%d@%H:%M:%S",localtime())
      </script>
      
      <!-- Format the test group and suite names to create folder -->
      <script>        
        FormattedTestcase=format_testcase()
        FormattedTestgroup=FormattedTestcase.group(ThisGroupName)         
        FormattedTestsuite=FormattedTestcase.suite(ThisSuiteName)
             
        TestLogDir= '%s/%s' % (logsTestsDir,FormattedTestgroup)
        TestLogFile='%s/%s' % (TestLogDir,FormattedTestsuite) 
      </script>
                  
      <call function="'WriteLogsForTestCase'">
        { 'starttime' : TestSuiteStartTime,
          'endtime'   : TestSuiteEndTime,
          'tofile'    : TestLogFile }
      </call>

      <script>
        if CurrentTestPath.has_key('suite'):
           del CurrentTestPath['suite']
      </script>
              
    </sequence>
  </function>

  <function name="testGroup_Preamble">
    <function-prolog>
      Performs all the pre operations for a test group
    </function-prolog>
    <function-no-args />
    <sequence>
    
      <!-- Take the values from the current test path -->     
      <script>
        if not CurrentTestPath.has_key('group'):
          CurrentTestPath['group']='unknown-group'
        
        ThisGroupName=CurrentTestPath['group']          
      </script>
      
      <message>'##### %s group preamble #####' % ThisGroupName</message>
      
    </sequence>
  </function>

  <function name="testGroup_Postamble">
    <function-prolog>
      Performs all the post operations for a test group
    </function-prolog>
    <function-no-args />
    <sequence>
    
      <script>
        if CurrentTestPath.has_key('group'):
          ThisGroupName=CurrentTestPath['group']
        else:
          ThisGroupName='unknown-group'
      </script>
      
      <message>'##### %s group postamble #####' % ThisGroupName</message>
      
      <script>
        if CurrentTestPath.has_key('group'):
          del CurrentTestPath['group']
      </script>
      
    </sequence>
  </function>
  
  <function name="WriteLogsForTestCase">

    <function-prolog>
      Queries the staf logs for the test case and write to file as text
    </function-prolog>
    <function-map-args>
      <function-arg-def name="starttime" type="required">
        <function-arg-description>
          timestamp to start logging from
        </function-arg-description>
        <function-arg-property name="type" value="timestamp"/>
      </function-arg-def>   
      <function-arg-def name="endtime" type="required">
        <function-arg-description>
          timestamp to start logging to
        </function-arg-description>
        <function-arg-property name="type" value="timestamp"/>
      </function-arg-def>
      <function-arg-def name="tofile" type="required">
        <function-arg-description>
          name of file to write the logs
        </function-arg-description>
        <function-arg-property name="type" value="filepath"/>
      </function-arg-def>                
    </function-map-args>

    <sequence>

      <call function="'queryLogs'">
        { 'location'  : STAXServiceMachine,
          'logname'   : 'STAX_Job_%s_User' % STAXJobID, 
          'startfrom' : starttime,
          'endat'     : endtime }
      </call>

      <call function="'WriteLogs'">
        { 'queryresult' : STAFResult, 
          'logfile'     : tofile }
      </call>

    </sequence>

  </function>

  <function name="WriteLogs">

    <function-prolog>
      Process staf log query results and write them to a file
    </function-prolog>
    <function-map-args>
      <function-arg-def name="queryresult" type="required">
        <function-arg-description>
          result of the staf log query
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>   
      <function-arg-def name="logfile" type="required">
        <function-arg-description>
          name of the log file to where results are written
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>          
    </function-map-args>
    
    <sequence>

      <message>'Creating test log %s' % logfile</message>
     
      <script>
        NewLogDir=os.path.dirname(logfile)
      </script>
      
      <call function="'createFolder'">
        { 'location'   : STAXServiceMachine, 
          'foldername' : NewLogDir }
      </call>

      <script>
        testlogfh=open(logfile,'w')
      </script>
           
      <iterate var="element" in="queryresult">
        <script>
          level=element['level'] 
          message=element['message']
          timestamp=element['timestamp']

          testlogfh.write('%s %s %s\n' % (timestamp,level,message))
        </script>

      </iterate>

      <script>testlogfh.close()</script>

    </sequence>

  </function>
	
  
   
  <function name="CheckMatches">
    <function-prolog>
      check the number of matching sub-string in a string
    </function-prolog>
    <function-map-args>
      <function-arg-def name="string2find" type="required">
        <function-arg-description>
          the sub-string to check
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>
      <function-arg-def name="mainString" type="required">
        <function-arg-description>
          the main string where the search is done
        </function-arg-description>
        <function-arg-property name="type" value="string"/>
      </function-arg-def>
      <function-arg-def name="nbExpected" type="optional" default="1">
        <function-arg-description>
          number of expected sub-string that must be in the main string
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>
    </function-map-args>
      
    <sequence>
      <script>
        nbFound = mainString.count(string2find)
        if nbFound == nbExpected:
            myMessage = 'SUCCESS : %s matches %s time(s) (expected %s)' % (string2find,nbFound,nbExpected)
            myRC=0
        else:
            myMessage = 'ERROR : %s matches %s time(s) (expected %s) in "%s"' % (string2find,nbFound,nbExpected,mainString)
            myRC=1
      </script>
      <if expr="myRC == 0">
        <sequence>
          <tcstatus result="'pass'"/>
            <message log="1">
              '%s' % myMessage
            </message>
        </sequence>
        <else>
          <sequence>
            <tcstatus result="'fail'"/>
            <message log="1" level="'Error'">
              '%s' % myMessage
            </message>
          </sequence>
        </else>
      </if>
      <return>myRC,myMessage</return>
    </sequence>
  </function>
  
  <function name="runFunction">
    <function-map-args>
      <function-arg-def name="functionName" type="required">
        <function-arg-description>
          Name of the function to run
        </function-arg-description>
      </function-arg-def>

      <function-arg-def name="functionArguments" type="optional">
        <function-arg-description>
          Arguments to be passed on to the called function.
          This can be a map or a list of arguments, whatever the called function
          expects will be carried on here.
          . for a map, pass the arguments like this:
            { 'argumentA' : 'argumentAvalue' ,
              'argumentB' : 1 ,
              ...
            }
          . for a list, pass the arguments like this:
            [ 'argumentAvalue, 1, ... ]
        </function-arg-description>
      </function-arg-def>

      <function-arg-def name="expectedRC" type="optional" default="0">
        <function-arg-description>
          The expected return code of the function to run.
          This is then passed onto the checkRC function.
          It is also used to throw an exception if the argument 
          functionException is provided and set the test case status if the
          argument functionSetsTCStatus is provided
        </function-arg-description>
        <function-arg-property name="type" value="integer"/>
      </function-arg-def>

      <function-arg-def name="functionException" type="optional">
        <function-arg-description>
          The exception to throw if the return code differs from the expected 
          RC. The exception is appended to STAXException.
        </function-arg-description>
      </function-arg-def>
      
      <function-arg-def name="functionMessage" type="optional">
        <function-arg-description>
          An optional message to display before running the function
        </function-arg-description>
      </function-arg-def>
      
      <function-arg-def name="functionSetsTCStatus" type="optional">
        <function-arg-description>
          Whether the function to run sets the testcase status or not.
          If this is set, the test case status is set according to whether
          or not the function meets the expected return code.
          True or False should be used for this argument.
        </function-arg-description>
      </function-arg-def>
      
      <function-arg-def name="functionFailureTC" type="optional">
        <function-arg-description>
          If this argument is provided, a testcase will be created with 
          this argument's value for name and set to fail only upon failure
        </function-arg-description>
      </function-arg-def>
      
      <function-arg-def name="functionSignal" type="optional">
        <function-arg-description>
          If this argument is provided, a signal will be raised upon unsuccesful
          execution of the function to run
        </function-arg-description>
      </function-arg-def>
      
      <function-arg-def name="functionCallBack" type="optional">
        <function-arg-description>
          If this argument is provided then functionCallBack will be called
          after the execution of function name.
        </function-arg-description>
      </function-arg-def>
      
      <function-arg-def name="functionCallBackArguments" type="optional">
        <function-arg-description>
           This allows to specify arguments for the call back function
        </function-arg-description>
      </function-arg-def>
    </function-map-args>
    <sequence>
      <script>
        <!-- defining the booleans here should temporary while I find a nicer
             solution. We have a chicken and egg problem between the 
             loadGlobalEnvironment and loadSharedLibraries functions in
             environment.xml at the moment. 
         -->
        if not False:
          False=0
          
        if not True:
          True=1
          
        _throwException=False
        if functionException:
          _throwException=True

        _displayMessage=False
        if functionMessage:
          _displayMessage=True

        _tcStatus='fail'
        _doSetTCStatus=False
        if functionSetsTCStatus:
          _doSetTCStatus=True
          
        _createFailureTC=False
        if functionFailureTC:
          _createFailureTC=True
      </script>
      <message log="1" level="'info'" if="_displayMessage == True">'%s' % functionMessage</message>
      <message log="1" level="'debug'">'runFunction: %s: called with parameters [%s]' % (functionName,functionArguments)</message>
      <call function="'%s' % functionName">functionArguments</call>
      <message log="1" level="'debug'">'runFunction: %s: returned [%s]' % (functionName,RC)</message>
      <script>
        _functionRC = RC
      </script>
      <call function="'checkRC'" >
        { 'returncode' : RC ,
          'result'     : STAXResult,
          'expected'   : expectedRC
        }
      </call>

      <!-- this section handles the optional case when we need to set the 
           test case status
       -->
      <if expr="_doSetTCStatus == True">
        <sequence>
          <if expr="_functionRC == expectedRC">
            <script>_tcStatus='pass'</script>
          </if>
          <tcstatus result="_tcStatus" />
        </sequence>
      </if>

      <!-- this section handles the optional case when we need to throw an
           exception upon unexpected function return code
       -->
      <if expr="_throwException == True" >
        <if expr="_functionRC != expectedRC" >
          <throw exception="'STAXException.%s' % functionException" />
        </if>
      </if>
      
      <!-- this section handles the optional case when we need to set a 
           test case status to fail to reflect the failure in the test report.
      -->
      <if expr="_createFailureTC == True" >
        <if expr="_functionRC != expectedRC" >
          <testcase name="'!!! %s [%s]' % (functionFailureTC,functionName)">
            <tcstatus result="'fail'" />
          </testcase>
        </if>
      </if>
      
      <!-- TODO: implement the signal raising mechanism -->
      <!-- TODO: implement the call back function mechanism -->
      
      <!-- bubble the function return code up one level -->
      <return>_functionRC</return>
    </sequence>
  </function>
  
</stax>

<?xml version="1.0" encoding="UTF-8"?>
<!--
  ! CCPL HEADER START
  !
  ! This work is licensed under the Creative Commons
  ! Attribution-NonCommercial-NoDerivs 3.0 Unported License.
  ! To view a copy of this license, visit
  ! http://creativecommons.org/licenses/by-nc-nd/3.0/
  ! or send a letter to Creative Commons, 444 Castro Street,
  ! Suite 900, Mountain View, California, 94041, USA.
  !
  ! You can also obtain a copy of the license at
  ! trunk/opendj3/legal-notices/CC-BY-NC-ND.txt.
  ! See the License for the specific language governing permissions
  ! and limitations under the License.
  !
  ! If applicable, add the following below this CCPL HEADER, with the fields
  ! enclosed by brackets "[]" replaced with your own identifying information:
  !      Portions Copyright [yyyy] [name of copyright owner]
  !
  ! CCPL HEADER END
  !
  !      Copyright 2011-2012 ForgeRock AS
  !    
-->
<chapter xml:id='chap-reading'
 xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en'
 xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
 xsi:schemaLocation='http://docbook.org/ns/docbook http://docbook.org/xml/5.0/xsd/docbook.xsd'
 xmlns:xlink='http://www.w3.org/1999/xlink'
 xmlns:xinclude='http://www.w3.org/2001/XInclude'>
 <title>Searching &amp; Comparing Directory Data</title>

 <para>Traditionally directories excel at serving read requests. This chapter
 covers the read (search and compare) capabilities that OpenDJ LDAP Java SDK
 provides. The data used in examples here is <link xlink:show="new"
 xlink:href="http://opendj.forgerock.org/Example.ldif">available
 online</link>.</para>

 <section xml:id="about-searching">
  <title>About Searching</title>
  <itemizedlist>
   <para>An LDAP search looks up entries based on the following
   parameters.</para>
   <listitem>
    <para>A <firstterm>filter</firstterm> that indicates which attribute values
    to match</para>
   </listitem>
   <listitem>
    <para>A <firstterm>base DN</firstterm> that specifies where in the
    directory information tree to look for matches</para>
   </listitem>
   <listitem>
    <para>A <firstterm>scope</firstterm> that defines how far to go under
    the base DN</para>
   </listitem>
   <listitem>
    <para>A list of attributes to fetch for an entry when a match is
    found</para>
   </listitem>
  </itemizedlist>
  
  <para>For example, imagine you must write an application where users login
  using their email address and a password. After the user logs in, your
  application displays the user's full name so it is obvious who is logged in.
  Your application is supposed to go to the user directory both for
  authentication, and also to read user profile information. You are told the
  user directory stores user profile entries under base DN
  <literal>ou=People,dc=example,dc=com</literal>, that email addresses are
  stored on the standard <literal>mail</literal> attribute, and full names are
  store on the standard <literal>cn</literal> attribute.</para>
  
  <para>You figure out how to authenticate from the chapter on authentication,
  in which you learn you need a bind DN and a password to do simple
  authentication. But how do you find the bind DN given the email? How do you
  get the full name?</para>
  
  <para>The answer to both questions is that you do an LDAP search for the
  user's entry, which has the DN that you use to bind, and you have the server
  fetch the <literal>cn</literal> attribute in the results. Your search uses
  the following parameters.</para>
  <itemizedlist>
   <listitem>
    <para>The filter is
    <literal>(mail=<replaceable>emailAddress</replaceable>)</literal>, where
    <replaceable>emailAddress</replaceable> is the email address the user
    provided.</para>
   </listitem>
   <listitem>
    <para>The base DN is the one given to you,
    <literal>ou=People,dc=example,dc=com</literal>.</para>
   </listitem>
   <listitem>
    <para>For the scope, you figure the user entry is somewhere under the base
    DN, so you opt to search the whole subtree.</para>
   </listitem>
   <listitem>
    <para>The attribute to fetch is <literal>cn</literal>.</para>
   </listitem>
  </itemizedlist>
  
  <para>The following code excerpt demonstrates how this might be done in a
  minimal command-line program.</para>

  <programlisting language="java">// Prompt for mail and password.
Console c = System.console();
if (c == null) {
    System.err.println("No console.");
    System.exit(1);
}

String mail = c.readLine("Email address: ");
char[] password = c.readPassword("Password: ");

// Search using mail address, and then bind with the DN and password.
final LDAPConnectionFactory factory = new LDAPConnectionFactory(host,
        port);
Connection connection = null;
try {
    connection = factory.getConnection();
    SearchResultEntry entry = connection.searchSingleEntry(baseDN,
            SearchScope.WHOLE_SUBTREE, "(mail=" + mail + ")", "cn");
    DN bindDN = entry.getName();
    BindResult result = connection.bind(bindDN.toString(), password);

    if (result.isSuccess()) {
        String cn = entry.getAttribute("cn").firstValueAsString();
        System.out.println("Hello, " + cn + "!");
    } else {
        System.err.println("Failed to bind.");
    }
} catch (final ErrorResultException e) {
    System.err.println("Failed to bind.");
    System.exit(e.getResult().getResultCode().intValue());
    return;
} catch (final InterruptedException e) {
    System.err.println(e.getMessage());
    System.exit(ResultCode.CLIENT_SIDE_USER_CANCELLED.intValue());
    return;
} finally {
    if (connection != null) {
        connection.close();
    }
}</programlisting>
 </section>

 <section xml:id="basedn-and-scope">
  <title>Setting Search Base &amp; Scope</title>

  <para>Directory servers organize entries somewhat like a file system.
  Directory data is often depicted as an upside-down tree.</para>

  <mediaobject xml:id="figure-ldap-tree">
   <alt>Directory data is often depicted as an upside-down tree.</alt>
   <imageobject>
    <imagedata fileref="images/ldap-tree.png" format="PNG" />
   </imageobject>
   <textobject>
    <para>This figure shows three levels, the base DN for the suffix, a couple
    of organizational units, and three user entries.</para>
   </textobject>
  </mediaobject>

  <para>In the figure shown above, entries are represented by the relevant
  parts of their DNs. The entry with DN <literal>dc=example,dc=com</literal>
  is the base entry for a suffix. Under the base entry, you see two
  organizational units, one for people, <literal>ou=People</literal>, the other
  for groups, <literal>ou=Groups</literal>. The entries for people include
  those of Babs Jensen, Kirsten Vaughan, and Sam Carter.</para>

  <para>When you are searching for a person's entry somewhere under
  <literal>dc=example,dc=com</literal>, you can start from
  <literal>dc=example,dc=com</literal>, from
  <literal>ou=People,dc=example,dc=com</literal>, or if you have enough
  information to pinpoint the user entry and only want to look up another
  attribute value for example, then directly from the entry such as
  <literal>cn=Babs Jensen,ou=People,dc=example,dc=com</literal>. The DN of
  the entry where you choose to start the search is the base DN for the
  search.</para>

  <itemizedlist>
   <para>When searching, you also define the scope. Scope defines what entries
   the server considers when checking for entries that match your search.</para>
   <listitem>
    <para>For <literal>SearchScope.BASE_OBJECT</literal> the server considers
    only the base entry.</para>
    <para>This is the scope you use if you know the full DN of the object
    that interests you. For example, if your base DN points to Babs Jensen's
    entry, <literal>cn=Babs Jensen,ou=People,dc=example,dc=com</literal>, and
    you want to read some of Babs's attributes, you would set scope to
    <literal>SearchScope.BASE_OBJECT</literal>.</para>
   </listitem>
   <listitem>
    <para>For <literal>SearchScope.SINGLE_LEVEL</literal> the server considers
    all entries directly below the base entry.</para>
    <para>You use this scope if for example you want to discover organizational
    units under <literal>dc=example,dc=com</literal>, or if you want to find
    people's entries and you know they are immediately under
    <literal>ou=People,dc=example,dc=com</literal>.</para>
   </listitem>
   <listitem>
    <para>For <literal>SearchScope.SUBORDINATES</literal> the server considers
    all entries below the base entry.</para>
    <para>This scope can be useful if you know that the base DN for your search
    is an entry that you do not want to match.</para>
   </listitem>
   <listitem>
    <para>For <literal>SearchScope.WHOLE_SUBTREE</literal> (default) the server
    considers the base entry and all entries below.</para>
   </listitem>
  </itemizedlist>

  <para>In addition to a base DN and scope, a search request also calls for a
  search filter.</para>
 </section>

 <section xml:id="about-filters">
  <title>Working With Search Filters</title>

  <para>When you look someone up in the telephone directory, you use the value
  of one attribute of a person's entry (last name), to recover the person's
  directory entry, which has other attributes (phone number, address). LDAP
  works the same way. In LDAP, search requests identify both the scope of the
  directory entries to consider (for example, all people or all organizations),
  and also the entries to retrieve based on some attribute value (for example,
  surname, mail address, phone number, or something else). The way you express
  the attribute value(s) to match is by using a search filter.</para>

  <para>LDAP search filters define what entries actually match your request.
  For example, the following simple equality filter says, "Match all entries
  that have a surname attribute (sn) value equivalent to Jensen."</para>

  <literallayout class="monospaced">(sn=Jensen)</literallayout>

  <para>When you pass the directory server this filter as part of your search
  request, the directory server checks the entries in scope for your search to
  see whether they match.<footnote><para>In fact, the directory server probably
  checks an index first, and might not even accept search requests unless it
  can use indexes to match your filter rather than checking all entries in
  scope.</para></footnote> If the directory server finds entries that match,
  it returns those entries as it finds them.</para>

  <para>The example, <literal>(sn=Jensen)</literal>, shows a string
  representation of the search filter. The OpenDJ LDAP SDK lets you express
  your filters as strings, or as <literal>Filter</literal> objects. In both
  cases, the SDK translates the strings and objects into the binary
  representation sent to the server over the network.</para>

  <variablelist>
   <para>Equality is just one of the types of comparisons available in LDAP
   filters. Comparison operators include the following.</para>

   <varlistentry>
    <term>=</term>
    <listitem>
     <para>Equality comparison, as in <literal>(sn=Jensen)</literal>.</para>
     <para>This can also be used with substring matches. For example, to match
     last names starting with <literal>Jen</literal>, use the filter
     <literal>(sn=Jen*)</literal>. Substrings are more expensive for the
     directory server to index. Substring searches therefore might not be
     permitted for many attributes.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>&lt;=</term>
    <listitem>
     <para>Greater than or equal to comparison, which works
     alphanumerically.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>&gt;=</term>
    <listitem>
     <para>Greater than or equal to comparison, which works
     alphanumerically.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>=*</term>
    <listitem>
     <para>Presence comparison. For example, to match all entries having a
     <literal>userPassword</literal>, use the filter
     <literal>(userPassword=*)</literal>.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>~=</term>
    <listitem>
     <para>Approximate comparison, matching attribute values similar to the
     value you specify.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>[:dn][:<replaceable>oid</replaceable>]:=</term>
    <listitem>
     <para>Extensible match comparison. For example,
     <literal>(uid:dn:=bjensen)</literal> matches entries where
     <literal>uid</literal> having the value <literal>bjensen</literal> is
     a component of the entry DN.
     <literal>(lastLoginTime:1.3.6.1.4.1.26027.1.4.5:=-13w)</literal> matches
     entries with a last login time more recent than 13 weeks.</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <variablelist>
   <para>You can use boolean operators to build complex filters when a single
   filter comparison is not enough to express what to match.</para>

   <varlistentry>
    <term>&amp;</term>
    <listitem>
     <para>This binary operator matches entries that belong to the intersection
     of the two component filters, for example all users named Barbara whose
     last name starts with Jen,
     <literal>(&amp;(givenName=Barbara)(sn=Jen*))</literal>.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>|</term>
    <listitem>
     <para>This binary operator matches entries that belong to the union of the
     two component filters, for example all the users named Jensen or Smith,
     <literal>(|(sn=Jensen)(sn=Smith))</literal>.</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>!</term>
    <listitem>
     <para>This unary operator matches entries that do not match the filter.
     Use this in complex filters when you have already narrowed the scope,
     for example all users named Jensen whose first name is not Barbara,
     <literal>(&amp;(sn=Jensen)(!(givenName=Barbara)))</literal>.</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </section>

 <section xml:id="send-search-request">
  <title>Sending a Search Request</title>
  <para>TODO</para>
 </section>

 <section xml:id="get-search-results">
  <title>Getting Search Results</title>
  <para>TODO</para>
 </section>

 <section xml:id="abandon-search">
  <title>Abandoning an Incomplete Search</title>
  <para>TODO</para>
 </section>

 <section xml:id="handle-ldap-urls">
  <title>Working With LDAP URLs</title>
  <para>TODO</para>
 </section>

 <section xml:id="sort-search-results">
  <title>Sorting Search Results</title>
  <para>TODO</para>
 </section>

 <section xml:id="about-comparisons">
  <title>About Comparing</title>
  <para>TODO</para>
 </section>
</chapter>